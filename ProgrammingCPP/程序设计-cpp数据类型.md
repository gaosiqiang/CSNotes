# cpp数据类型
属于数据成分

## 基本数据类型
- 布尔型 bool
- 字符型 char
- 整形 int
- 实型（浮点型）
	- 单精度型 float
	- 双精度型 double

## 自定义数据类型
- 数组型（类型[]）
- 指针型（类型 *）
- 构造数据类型
	- 结构体型（struct）
	- 联合体型（union）
	- 枚举型（enum）
- 类（class）
- 空类型（void）

## 内存
在学习数据成分之前先了解内存的存储空间的一些基本知识。
1、内存存储单元：内存存储空间最小操作单元单位是Btye字节，每个字节有8bit数据，所以可以说内存最小的存储单元是字节Btye。
2、内存寻址地址：每个内存存储空间都有对应的内存寻址地址与内存的存储单元之间映射关系，地址一般是16进制的数据格式表示的。

## 变量
计算机中可以变化值的量标识符，类似于数学中设置的未知数x这个概念。

### 声明定义
#### 格式规范：
c&cpp中所有的变量都是要先定义再使用，程序中无法使用未定义的变量。

```c++
数据类型 变量名;
type varName; 定义变量可以不赋值。
type varName = value; 定义变量同时赋初始值的是初始化。
type varName1, varName2, varName3; 连续定义多个变量。
type varName1, varName2, varName3 = value; 混合定义变量使用。
```

#### demo：

```c++
int a;
int b = 10;
int c, d, e;
int f, g, h = 1;
char char1;
char char2 = 'A';
double number = 3.14;
```

#### 变量在内存中的存储原理
计算机执行变量定义的过程：抽象化，先不考虑程序的编译执行和解释执行的问题。
1、当计算机执行int max = 10;的这行代码的时候，计算机会在内存中开辟一个连续多个存储空间单元，多个连续存储空间组成的一个独立的空间。
2、然后给这个独立空间命名max。
3、然后将max的初始值10放到独立存储空间中。
4、并且同时记录下这个独立空间名字max与这个独立空间的**起始**存储单元的**寻址地址**之间的对应关系。
5、程序中再提及出现使用max这个变量的时候，计算机就会将max变量指向命名max的独立空间中。
6、当给变量max重新赋值的时候，计算机就会在max名称的独立空间把10改成8。

## 常量
字面常量的定义规范：直接在程序中写出来数据就是字面常量的定义。
3.14;//如果不在数据后面加上数据类型说明，系统默认认为是double类型
符号常量的定义规范：
const关键字：

	//规范
	const 数据类型 常量名 = 初始化值;
	//demo
	const int I = 1;//定义了常量I。

一个cpp文件内变量和常量的命名不能冲突。
符号常量在定义之初就要赋给初始化值，如何定义符号常量后再去赋值那么使用与常量就没有区别了。

## 整形
整数型数据，对应变量就是整数型变量。
### 整形的子类型
| 类型名称 | 有符号关键字 | 无符号关键字 | 声明定义格式 |
| :-- | :-- | :-- | :-- |
| 基本型 | int 等价于 signed int | unsigned int |
| 短整形 | short 等价于 short int 等价于 signed short 等价于 signed short int | unsigned short 等价于 unsigned short int |
| 长整形 | long 等价于 long int 等价于 signed long 等价于 signed long int | unsigned long 等价于 unsigned long int |

整形类型细化的区分原则是按照数据所占的内存空间的大小区分的。
1、定义int类型数据的时候，在内存中需要开辟32bit(位)的连续空间，也就是4Btye(字节)空间。
2、定义short类型数据的时候，在内存中需要开辟16bit(位)的连续空间，也就是2Btye(字节)空间。
3、定义long类型数据的时候，在内存中需要开辟32bit(位)的连续空间，也就是4Btye(字节)空间。
4、有符号整形型赋值范围0和正负整数，无符号整形赋值范围0和正整数。系统默认情况下定义的整形都是有符号的子类。

### 总结
因为不同的整形数据所占的内存空间不同，所表示的数据范围也是不同的。
因为c标准中对于数据所占内存空间字节数没有明确的规范，只有一个模糊的区间的范围。只要求long型数据长度不短于int型short型不长与int型，在有的编译器中int和long都是占用4个字节。所以导致了在不同的编译器中运行的结果不同。
通过sizeof运算符可知所在编译器的各种类型数据的所占字节数，`cout << sizeif(int); //输出4，这个编译器int型数据占4字节空间`
了解了每个子类型在存储空间内具体的存储方式，就知道场景下应该用什么子类型了，详情看’二进制的源码补码反码‘

### 数据范围
已知一个int类型数据是4个字节也就是32位bit。

无符号的int最大的数应该是32个bit位都是1，2^32=4294967296。实际上bit位全是1的数会被记为0，因为用全是0的bit位记为0在计算机层面上不容易理解。所以无符号的int类型最大数是2^32-1=4294967295，最小数0。
有符号的init最大数应该是31个bit位都是1，同理无符号int类型最大数是2^31-1=2147483647，最小数就是包括符号位所有bit位都是1，当符号位为1数据位全部为0时，最高位1即表示符号位也表示数据位，所以最小数2^31=-2147483648。因为这里与补码相关，详情看补码部分理解。

### 运算法则
整形数据与整形数据的运算结果也是整形数据。
demo

```c++
int a = 123;
cout << a / 10; //输出12，因为数学上123除以10是12.3，cpp会忽略小数点后的数据，所以得到的结果是12。
```

## 浮点型（实型）
### 单精度&双精度
内存中存储状况
有效值范围

精度位数：整数位数+小数位数=有效精度位数。系统默认打印是6位有效精度位数，可以通过操作运算符打印更多的精度位数。

## 字符型
字符的存储方式状况：字符型数据格式只占有1个字节，也就是8bit。
字符的ASCII码关系，8bit对应的是2^8个字符映射和内存存储二进制状况。
声明定义：char a = 'a';//使用单引号定义的是字符数据类型。
字符运算：字符类型与字符类型之间的四则运算、字符类型与int类型之间的四则运算、字符类型与浮点类型之间的运算都是将字符转换成ascii码对应的int数据进行的运算。

### 字符数组&字符串
c&cpp没有字符串这种数据类型的，如果有需要字符串可以使用字符数据类型数组实现：
char str1[4] = "abc";
这里的定义是用的双引号。

### 字符&字符数组&字符串的输入与输出
1、计算机的输入过程原理：
输入缓冲区，计算机设备键入的数据会先存放在计算机系统层面开辟出来的临时存储也就是输入缓冲区，然后程序感知到缓冲区有数据进而读取数据。
缓冲区指针，这个指针指向当前程序读取的输入缓冲区的数据，用来标明已读取的数据，程序读取后指针向后或者向下移动而且这个移动是不可逆的操作。
2、一个字符的输入与输出过程原理：
3、字符数组或字符串的输入和输出过程原理：用字符类型数组来接收和运算处理。

## 布尔型
布尔型：布尔只占用1一个字节8个bit，只要是非0的数据在布尔逻辑上都是true也就是1，只有8个bit都是0才是false，其他情况都是true。

布尔类型的真值逻辑是，只要是非0的都是true。

布尔类型占用一个字节，在内存中一个byte中所有的bit位都是0是false，其他情况都是true。

| 线位 | 0x0 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| bit位 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

声明定义：

```c++
bool is_true = true; //true
bool is_false = false; //false
bool is_bool = 1; //true
bool is_bool = 0; //false
int is_bool = true; //1
int is_bool = false; //0
```

## 数组
声明定义：

```c++
tyep arrayName[arraySize] = {element, element, element, .....};
```

demo：

```c++
//声明定义，指定索引范围的数组
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
//声明定义，动态索引范围的数组
int b[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

//引用，访问数组
cout << a[0]; //输出1
cout << a[9]; //输出10
cout << b[2] << endl; //输出3
//修改
a[1] = a[9] + a[8];
cout << a[1]; //输出19
```

数组在内存中存储原理：
c++的数组在内存中占用一个连续内存空间。这个数组对应一个的就是一个栈区。

二维数组和三维数组：
二维数组存储原理是将二维数组中的每个数组当成元素来处理，平铺成一维数组存储的。

声明定义：

```c++
typeName arrayName[arraySize][arraySize] = {
	{element, elementelement, .....},
	{element, elementelement, .....}
};
```

example：

```c++
//定义二维数组
int c[2][3] = {
	{1, 2, 3},
	{4, 5, 6}
};
//二维数组的访问
cout << c[0][1] << endl; //2
c[0][1] = 9;
cout << c[0][1] << endl; //9
//定义三维数组
int d[2][3][3] = {
	{
		{1, 2, 3},
		{4, 5, 6},
		{7, 8, 9}
	},
	{
		{10, 11, 12},
		{13, 14, 15},
		{16, 17, 18}
	}
};
//访问三维数组
cout << d[0][1][2] << endl; //6
```

