# 程序设计部分
c&cpp部分

[TOC]

## 学习程序设计的几个要点

- 程序设计属于应用范畴，是对知识的应用和实践。
- T字形学习策略，先平面的学习跟着书籍或者老师的节奏走，不要纠结于一个点的细节问题，可以先将这个问题设置一个锚点之后处理或者后面学习过程中就会迎刃而解。
- 阶段性学习方式，先设置一个可以完成的阶段性目标然后不断给予自己正反馈。


## 编程语言

编程语言：
先说说语言，语言的目的是交流。而程序设计语言就是人与计算机之间的交流语言。比如汇编语言就是其中的一种还有c和cpp等等跟多高级语言。高级语言更加接近于人类的语言。

汇编语言写的程序是程序c语言写的程序也是程序只是不同层面上而已都可以抽象归纳为程序。
编程语言就是程序设计语言。

## 程序设计思想阐述

程序设计就是用编程语言编写程序也就是用计算机的运算逻辑来思考问题的方式来设计解决问题的方案。

描述问题和描述解决方案是用逻辑性和结构化的语言来描述，这就是编程语言设计的出发点和原则。也是结构化设计原则的体现。

设计模式：

- 结构化设计，纲举目张的上下而下设计模式
- 穷举法，就是尝试所有的可能性的设计模式

## 程序调试
- log法，使用程序输出数据打印暂停程序的方式观察程序运行过程的调试方式。
- ide Debug，使用ide的debug断点功能观察程序运行过程的调试方式，不同的ide的debug功能不尽相同。

## 结构化程序设计语言语法组成部分
- 关键字（保留字）：语言设计之初就是定义了关键字。
- 数据类型
- 运算符
- 句式结构：编程语言中的基础逻辑结构只有这3种（顺序，分支，循环）
- 标识符：常量名，变量名，函数名，数组名，类型名，文件名的有效字符序列称为标识符(identifier)，标识符只能由字母数字下划线构成而且第一个字符不可为数字。

## 程序设计语言的构成部分

### 学习一门高级编程语言的策略

先分析一个编程语言程序的构成部分

- 数据成分
- 运算成分
- 控制成分
- 传输成分

by 《计算机科学技术百科全书》
从这4个方面了解一门高级编程语言

### 学习方法
- 数据成分，只需了解有哪些数据类型以及使用。
- 运算成分，只需了解有哪些运算符号以及使用。
- 控制成分，三种类型格式和应用场景以及使用。
- 传输成分，了解在程序中程序是如何输入输出数据的。

### 学习路线
1、数据成分
2、控制成分
3、运算成分

## 编程语言分类

- 低级语言
	- 机器码语言
	- 汇编语言
- 高级语言发展历程
	- fortran语言，适用于数学方面
	- 算法语言Algol 60报告引发Algol 60语言诞生，也就是A语言
	- BCPL语言，是在ALgol 60基础上发展出CPL，后来简化版BCPL(Basic版)
	- 1970贝尔实验室，是Ken Thompson 为了开发操作系统在BCPL基础上简化出B语言，用B语言写了UNIX操作系统
	- 1972Dennis Ritchie和Ken Thompson在B语言基础上发展和完善出C语言，并用C语言重新UNIX系统

### c语言的标准发展：
1978年K&R C标准这个标准不是office标准
1989年C语言被ANSI标准化，对K&R C标准进行了拓展和少量修改，也规定了一套标准函数库
1990年ISO的WG14工作组标准化了C语言，编号ISO 9899:1990，ANSI组织是ISO组织的成员，后来ANSI也遵从ISO的标准
1999年WG14小组更新了标准，ISO 9899:1999，这个标准就是通常提及的C99标准
2011年通过了 ISO/IEC 9899:2011也就是C11标准

### c++语言的标准发展
1979年贝尔实验室Bjarne Stroustrup在c语言的基础上加上了面向对象，称为C with Classes后来演化成C++
1998年ISO颁布了ISO/IEC 14882-1998的C++标准
2011年ISO颁布了ISO/IEC 14882:2011的C++标准，也就是通常所说的C++2011

### PS
- c语言是无法直接执行的，需要通过编译器编译成汇编语言然后执行。有可能相同的代码在不同的编译器运行结果会不同。
- 编程语言的高低不反应实际的高低，这里的高低分类只是相对于人类语言而言是否容易编程和理解的程度。


---------

## 数据类型
属于数据成分

### 基本数据类型
- 布尔型 bool
- 字符型 char
- 整形 int
- 实型（浮点型）
	- 单精度型 float
	- 双精度型 double

### 自定义数据类型
- 数组型（类型[]）
- 指针型（类型 *）
- 构造数据类型
	- 结构体型（struct）
	- 联合体型（union）
	- 枚举型（enum）
- 类（class）
- 空类型（void）

### 内存
在学习数据成分之前先了解内存的存储空间的一些基本知识。
1、内存存储单元：内存存储空间最小操作单元单位是Btye字节，每个字节有8bit数据，所以可以说内存最小的存储单元是字节Btye。
2、内存寻址地址：每个内存存储空间都有对应的内存寻址地址与内存的存储单元之间映射关系，地址一般是16进制的数据格式表示的。

## 变量
计算机中可以变化值的量标识符，类似于数学中设置的未知数x这个概念。

### 声明定义
#### 格式规范：
c&cpp中所有的变量都是要先定义再使用，程序中无法使用未定义的变量。

```c++
数据类型 变量名;
type varName; 定义变量可以不赋值。
type varName = value; 定义变量同时赋初始值的是初始化。
type varName1, varName2, varName3; 连续定义多个变量。
type varName1, varName2, varName3 = value; 混合定义变量使用。
```

#### demo：

```c++
int a;
int b = 10;
int c, d, e;
int f, g, h = 1;
char char1;
char cher2 = 'A';
double number = 3.14;
```

#### 变量在内存中的存储原理
计算机执行变量定义的过程：抽象化，先不考虑程序的编译执行和解释执行的问题。
1、当计算机执行int max = 10;的这行代码的时候，计算机会在内存中开辟一个连续多个存储空间单元，多个连续存储空间组成的一个独立的空间。
2、然后给这个独立空间命名max。
3、然后将max的初始值10放到独立存储空间中。
4、并且同时记录下这个独立空间名字max与这个独立空间的**起始**存储单元的**寻址地址**之间的对应关系。
5、程序中再提及出现使用max这个变量的时候，计算机就会将max变量指向命名max的独立空间中。
6、当给变量max重新赋值的时候，计算机就会在max名称的独立空间把10改成8。

## 常量
字面常量的定义规范：直接在程序中写出来数据就是字面常量的定义。
3.14;//如果不在数据后面加上数据类型说明，系统默认认为是double类型
符号常量的定义规范：
const关键字：

	//规范
	const 数据类型 常量名 = 初始化值;
	//demo
	const int I = 1;//定义了常量I。

一个cpp文件内变量和常量的命名不能冲突。
符号常量在定义之初就要赋给初始化值，如何定义符号常量后再去赋值那么使用与常量就没有区别了。

## 整形
整数型数据，对应变量就是整数型变量。
### 整形的子类型
| 类型名称 | 有符号关键字 | 无符号关键字 | 声明定义格式 |
| :-- | :-- | :-- | :-- |
| 基本型 | int 等价于 signed int | unsigned int |
| 短整形 | short 等价于 short int 等价于 signed short 等价于 signed short int | unsigned short 等价于 unsigned short int |
| 长整形 | long 等价于 long int 等价于 signed long 等价于 signed long int | unsigned long 等价于 unsigned long int |

整形类型细化的区分原则是按照数据所占的内存空间的大小区分的。
1、定义int类型数据的时候，在内存中需要开辟32bit(位)的连续空间，也就是4Btye(字节)空间。
2、定义short类型数据的时候，在内存中需要开辟16bit(位)的连续空间，也就是2Btye(字节)空间。
3、定义long类型数据的时候，在内存中需要开辟32bit(位)的连续空间，也就是4Btye(字节)空间。
4、有符号整形型赋值范围0和正负整数，无符号整形赋值范围0和正整数。系统默认情况下定义的整形都是有符号的子类。

### 总结
因为不同的整形数据所占的内存空间不同，所表示的数据范围也是不同的。
因为c标准中对于数据所占内存空间字节数没有明确的规范，只有一个模糊的区间的范围。只要求long型数据长度不短于int型short型不长与int型，在有的编译器中int和long都是占用4个字节。所以导致了在不同的编译器中运行的结果不同。
通过sizeof运算符可知所在编译器的各种类型数据的所占字节数，`cout << sizeif(int); //输出4，这个编译器int型数据占4字节空间`
了解了每个子类型在存储空间内具体的存储方式，就知道场景下应该用什么子类型了，详情看’二进制的源码补码反码‘

### 数据范围
已知一个int类型数据是4个字节也就是32位bit。

无符号的int最大的数应该是32个bit位都是1，2^32=4294967296。实际上bit位全是1的数会被记为0，因为用全是0的bit位记为0在计算机层面上不容易理解。所以无符号的int类型最大数是2^32-1=4294967295，最小数0。
有符号的init最大数应该是31个bit位都是1，同理无符号int类型最大数是2^31-1=2147483647，最小数就是包括符号位所有bit位都是1，当符号位为1数据位全部为0时，最高位1即表示符号位也表示数据位，所以最小数2^31=-2147483648。因为这里与补码相关，详情看补码部分理解。

### 运算法则
整形数据与整形数据的运算结果也是整形数据。
demo

```c++
int a = 123;
cout << a / 10; //输出12，因为数学上123除以10是12.3，cpp会忽略小数点后的数据，所以得到的结果是12。
```

## 浮点型（实型）
### 单精度&双精度
内存中存储状况
有效值范围

精度位数：整数位数+小数位数=有效精度位数。系统默认打印是6位有效精度位数，可以通过操作运算符打印更多的精度位数。

## 字符型
字符的存储方式状况：字符型数据格式只占有1个字节，也就是8bit。
字符的ASCII码关系，8bit对应的是2^8个字符映射和内存存储二进制状况。
生命定义：char a = 'a';//使用单引号定义的是字符数据类型。
字符运算：

### 字符数组&字符串
c&cpp没有字符串这种数据类型的，如果有需要字符串可以使用字符数据类型数组实现：
char str1[4] = "abc";
这里的定义是用的双引号。

### 字符&字符数组&字符串的输入与输出
1、计算机的输入过程原理：
输入缓冲区，计算机设备键入的数据会先存放在计算机系统层面开辟出来的临时存储也就是输入缓冲区，然后程序感知到缓冲区有数据进而读取数据。
缓冲区指针，这个指针指向当前程序读取的输入缓冲区的数据，用来标明已读取的数据，程序读取后指针向后或者向下移动而且这个移动是不可逆的操作。
2、一个字符的输入与输出过程原理：
3、字符数组或字符串的输入和输出过程原理：用字符类型数组来接收和运算处理。

## 布尔型
布尔型：布尔只占用1一个字节8个bit，只要是非0的数据在布尔逻辑上都是true也就是1，只有8个bit都是0才是false，其他情况都是true。

布尔类型的真值逻辑是，只要是非0的都是true。

布尔类型占用一个字节，在内存中一个byte中所有的bit位都是0是false，其他情况都是true。

| 线位 | 0x0 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| bit位 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

## 数组
声明定义：tyep arrayName[arraySize] = {element, element, element, .....};
demo：	

```c++
/声明定义
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
//引用
cout << a[0]; //输出1
cout << a[9]; //输出10
//修改
a[1] = a[9] + a[8];
cout << a[1]; //输出19
```
数组在内存中存储原理：
c++的数组在内存中占用一个连续内存空间。这个数组对应一个的就是一个栈区。

二维数组：
是将二维数组平铺成一位数组存储的。
三维数组：

demo：

## 二进制的原码补码反码
### 下面是模拟的4个字节的内存空间制表

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

### 程序中定义了一个无符号整形变量a
`unsigned int a = 123;` 
内存中存储状况是

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 1 |

### 程序中定义了一个有符号整形变量a
`int a = -123;` 
内存中存储状况是

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 1 |

### 符号位
上面的情况可知有符号整形数据在内存存储状况中，第一位地址0x1的bit位不用来作为数据的计数，用来当做符号位，用其他剩余的bit表示具体的数据。
符号位的表示逻辑是：1表示是负数，0表示正数。

### 原码
二进制原码就是数据对应的二进制编码自身。

demo
十进制：123 对应的二进制：1111011

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 1 |

十进制：-123 对应的二进制 符号位+1111011

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 1 |

以上都是二进制的原码。

### 反码
反码通常是用来由原码求补码或者由补码求原码的过渡码。
正数的反码跟原码相同；负数的反码就是原码除符号位外其他位按位取反（0换1和1换0）

demo
十进制：123 对应的二进制原码：1111011

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 1 |
十进制：123 对应的二进制反码：1111011

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 1 |

十进制：-123 对应的二进制原码：符号位+1111011；

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 1 |

十进制：-123 对应的二进制反码：符号位+0000100

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |

### 补码
在计算机中，存储数据不是直接存储数据对应的二进制原码，而是存储数据对应二进制的补码。
正数的二进制补码与原码相同。
负数的二进制补码是负数原码的反码+1，负数的补码的反码+1就会得出负数的原码。

demo
十进制：123；二进制原码反码补码都是：1111011

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 1 |

十进制：-123；二进制补码：反码+1

| 地址 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 | 0x8 | 0x9 |  0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x20 | 0x21 | 0x22 | 0x23 | 0x24 | 0x25 | 0x26 | 0x27 | 0x28 | 0x29 | 0x30 | 0x31 | 0x32 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| bit位 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 1 |

0x32地址对应bit数据是0，加1后变成1

### 补码的意义
1、解决了符号的表示的问题。
2、可以将减法运算转化为补码的加法运算来实现，克服了原码加减法运算繁杂的弊端，可有效简化运算器的设计。
3、在计算机中，利用电子器件的特点实现补码和真值、原码之间的相互转换，非常容易。

- 引用[百度百科](https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613)  

### 总结
- bit位的最高位是1的都按照负数的规范处理。
- 只有数字的存储是补码。
- bit最高位是0原码转补码：原码等于反码，原码等于补码。
- bit最高位是1原码转补码：补码等于原码的反码+1。

## 运算成分
### 运算符
运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。
c语言的运算符相对于其他编程语言的运算符是比较多的。c语言的运算符不仅多而且功能强大。
cpp的运算符比c语言的运算符还要强大，因为cpp中有运算符重载机制，可以赋予运算符更多的含义和功能。
后来诞生的编程语言都意识的淡化运算符的作用。

#### 运算符分类
cpp内置了丰富的运算符，并提供了以下类型的运算符：

##### 算术运算符
优先级：

| 4 | 3 | 2 | 1 |
|---|---|---|---|
| ++，-- |  () | *，/，% | +，- |

运算过程中的数据类型的转换方向：
1、整数与整形运算得到的结果是整数。
2、短整形与整形运算是先将短整形转换成整形，得到的结果是整形。
3、短整型或整形与长整形运算先都转换成长整形，得到的结果是长整形。
4、实数与（实数，整形，字符）运算先都转换成double类型，得到的结果都是double，因为double的精度的问题小数位最后一位是舍入的方向随编译器的不同而不同。
5、有符号与无符号运算先将无符号转换成有符号，结果是都是有符号。
6、整形与字符运算先转换成整形，结果是整形。

总结：
1、运算过程中数据类型级别低的向高转换。
2、类型的转换实质上是转换数据在内存存储空间的bit位的数据映射数据，就是bit位的数据不动，只是二进制数据的表达格式的转化。
3、所以类型转换监控就可以将bit位的二进制数据用十六进制或八进制输出检查。
4、表达值的数据类型取决于表达包含的最高级别的数据类型。

##### 关系运算符
1、高优先级：
<，<=，>，>=
2、低优先级：
==，!=
3、优先级方向：向右，就是先左后右。
4、关系运算表达式返回值是bool值。

##### 逻辑运算符
优先级：
非!  > 与&& > 或||
逻辑短路：
1、与&&：表达式1 && 表达式2，当表达式1的值为0或false时，逻辑表达式直接返回false不只执行表达式2了。
2、或||：表达式1 || 表达式2，当表达式1的值非0或true时，逻辑表达式直接返回true不只执行表达式2了。



##### 位运算符
定义：位运算是对内存存储空间字节的每个二进制位的数所进行的运算。在内存中字节是程序对内存进行操控的基本单位，位运算虽然是对二进制位进行的运算但实际上这种运算也是通过对字节为单位的控制来实现的。

类型：

| 名称 | 类型 |
|---|---|
| 按位与& | 双目运算符 |
| 按位或\| | 双目运算符 |
| 按位异或^ | 双目运算符 |
| 取反~ | 单目运算符 |
| 左移<< | 单目运算符 |
| 右移>> | 单目运算符 |

补充：
异或运算：参与运算的2个数相同逻辑真值为false，参与运算的2个数不同逻辑真值为true。
同或运算：与异或运算逻辑真好相反

应用：
1、a和b的值互换使用按位异或运算实现，不借用第三个变量和函数

```c++
a = a ^ b;
b = b ^ a;
a = a ^ b;
```

ps:
这里想象抽象的将每个bit位平铺和竖立两种排列方式。平铺的左端对应的竖立的高位，平铺的右端对应的竖立的低位。
位运算是对存储的bit位的运算，如果是数字类型数据那么是对原码的补码做的位运算，运算结果还要推导成原码，然后获取表示。

##### 赋值运算符
功能定义：
给左边的变量或常量做赋值运算。

基本使用：
1、变量赋值 varName = value;
2、定义初始化 type varName = value;

进阶用法：
1、运算符两边的数据类型不同的赋值运算会先类型转换，具体是将右边的赋值数据类型向左边的数据类型转换。
int a = 3.14;//只保留整数部分，输出3
float b = 3;//默认会补小数位，默认输出6位精度3.00000
char c = 64;//会赋予ASCII码64对应的字符，输出@
2、占用内存存储空间大的数据类型赋给占用内存存储空间小的数据类型。系统会将占用空间大数据类型在内存存储空间中对应的二进制bit位从后面向前截取占用内存存储空间小数据类型对应的的二进制bit位长度，最后将截取的二进制bit对应的值赋给占用内存存储空间小的数据类型。
int a = 123123;
char b = ' ';//定义一个空格
b = a;//将123123对应的二进制bit位截取后面的8个bit，然后将8个bit对应的十进制数字所对应的ASCII码的字符赋值给b。
3、占用内存存储空间小的数据类型赋给占用内存存储空间大的数据类型，那么原来是什么数据，赋值后依然还是什么数据。这个比较容易理解，可以理解成不够的bit位自动向上补0。
4、将有符号数据类型的值赋给无符号数据类的值相互赋值，会直接搬运将数据对应的二进制bit位的符号位的bit当成数字bit。
5、将无符号数据类型的值赋给有符号数据类的值相互赋值，会直接搬运将数据对应的二进制bit位的最高位的bit当成符号位。
6、复合赋值运算：+=，=+ 等等，
7、连续赋值运算：a = b = 5;//a和b都是定义好的变量，可以这样连续赋值；int a = b = c = 5;//c&cpp中赋值运算不可这样连续使用，其他动态语言可以；a = (b = 4) + (c = 6);//a为10，b为4，c为6；
8、赋值运算表达式的返回值是赋值的值。a = 10;//这个表达式返回值是10，其他语言返回是1或者是true。

##### 其他运算符
1、逗号运算符,；逗号运算符是用来连接表达式的运算符；使用：表达式1, 表达式2, 表达式;，用逗号连接多个表达式组成的逗号表达式就是逗号表达式，执行顺序是执行表达式1然后是表达式2然后是表达式3，逗号表达式的值是其中最后一个执行表达式的值。
demo：1，2，3;这个逗号表达式的值是3
2、三目运算：表达式1 ? 表达式2 : 表达式3;如果表达式1为真，三目运算表达式的值为表达式2的值反之就是表达式2的值。
3、强制类型转换运算符：就是将表达式的值数据类型强转换成指定类型的运算，注意是表达的值，而表达式原来的指向的内存存储空间对应的数据类型是不变的，只是体现在这个强制类型转换表达中。定义：(typeName) 表达式; 。demo：(int) a;//强制将(int) a;这个表达式值数据类型转换成int类型，但是变量a依然还是原来的数据类型不会发生改变。

##### 优先级的关系链
括号组() > 逻辑非! > 算数运算 > 关系运算 > 逻辑与&&和逻辑或|| > 赋值运算 > 逗号运算

参考‘运算优先级列表’。

表达式运算结果分析方法1，借鉴数学中的合并同类项的思想，同等级归纳法分析。
表达式运算结果分析方法2，用运算符的优先级做火焰图，然后由上至下顺序分析。

## 控制成分
### 顺序
### 判断
#### if判断
#### switch判断
### 循环
#### for循环

```c++
for(;;)
{
	code;
}
```
这样的for循环是死循环，不判断for循环中的条件表达式，不断的执行代码块。

#### while循环
while循环容易造成死循环，因为只要while条件为真那么就会执行代码块。

#### do while循环

#### goto语句
特点：无条件转向语句。
拓展：在汇编语言中也有goto语句，这就让汇编语言也可以实现各种循环逻辑。
不足：从软件工程的层面出发不建议在高级语言程序中使用goto语句，goto语句使程序不便于阅读和理解，代码结构不清晰直观。goto也不利于**程序正确性的证明**

历史：
1965年IFIP会议上Dijkstra提出‘程序的质量与程序中包含goto语句的数量成反比’，但是当时FORTRAN广泛使用，而goto是FORTRAN的支柱逻辑。
六七十年代的计算机性能比较低下，所以比较重视程序的执行效率，而goto是能够提升程序的效率的，当然提升的也是非常有限，所以被大量的使用和保留，但是现在程序已经不限于一点点的算力的束缚。
1974年Donald Ervin Knuth高德纳全面的总结是：不加限制的使用goto会让程序难以理解，在不破坏程序结构性的前提下为了提升程序效率有控制的使用goto是有必要的。


#### break语句
break语句只能跳出本loop，但是其他语言是可以在break numbner;设置一个整数参数，决定跳出第几层循环，从所在循环层数1为起始。

#### continue语句

## 计数语法规范
在c&cpp语言中：

变量赋值的数据格式是`0x+数据`，系统会识别成十六进制；变量赋值的数据格式是`0+数据`，系统会识别成八进制；0b+二进制数据，系统会识别成二进制；
demo：

```c++
int a = 10;//系统识别成十进制数据
int b = 0xffff85;//系统识别成十六进制数据，hex是十六进制的简称还有的系统内是用：h123表示十六进制
int c = 0377777;//系统识别成八进制数据
int e = 0b11;//系统识别二进制，cout << dec << e;  输出二进制11对应的十进制3
```
c&cpp支持科学计数法：0.123e5 本质上是 0.123*10^5
demo：

```c++
float f = 0.123e5;
```

c&cpp中经常发现大量使用十六进制的和八进制的数据类型，是因为十六进制和八进制相对比较直观的反映程序中二进制的实际状况。

有的时候数据出现意想不到的问题，要多从二进制基础底层的思维去理解。

表达式：程序中有运算符，操作数，括号组等等所组成的计算机，是计算求值的基本单元。表达式都会有返回值的。

c&cpp文件的预定义部分：

```c++
#include <iostream>
using namespace std;
```

c&cpp的ISO标准是编译器编译c&cpp的编译标准而非代码语法标准。

cout本质是个cpp对象，当 cout << xxxx; 等价于 cout.构造函数(xxxx);。

转义字符的意义和应用。

## Alog&DS
- 冒泡排序
- 选择排序

## PS
- 只要你客观的观察这个世界，你就会发现它是如此的简单，以至于就像我们所想象的那样。正因如此我们的思考才有价值。
- 保证程序的可读性，添加注释和例子，规范化参数和返回数据。保证代码的健壮性和可读性。

## Even Log
- end 笔记记录到‘c语言中的数据成分-最大与最小整数’ by 202107212103
- add 笔记记录到‘c语言中的控制成分’ by 202107220908
- add 学习了‘c语言中的数组’ by 202107230900
- add 没有做‘c语言中的数组’笔记 by 202107230930
- add 学习了‘c程序中的字符串’ by 2021071735
- add 没有做‘c程序中的字符串’笔记 by 2021071845

