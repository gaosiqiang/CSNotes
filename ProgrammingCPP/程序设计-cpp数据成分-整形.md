# 数据成分-整形
整数型数据，定义整形数据类型的变量就是整数型变量。
## 1、整形的子类型
| 类型名称 | 有符号关键字 | 无符号关键字 | 声明定义格式 |
| :-- | :-- | :-- | :-- |
| 基本型 | int 等价于 signed int | unsigned int |
| 短整形 | short 等价于 short int 等价于 signed short 等价于 signed short int | unsigned short 等价于 unsigned short int |
| 长整形 | long 等价于 long int 等价于 signed long 等价于 signed long int | unsigned long 等价于 unsigned long int |

整形类型细化的区分原则是按照数据所占的内存空间的大小区分的。
1、定义int类型数据的时候，在内存中需要开辟32bit(位)的连续空间，也就是4Btye(字节)空间。
2、定义short类型数据的时候，在内存中需要开辟16bit(位)的连续空间，也就是2Btye(字节)空间。
3、定义long类型数据的时候，在内存中需要开辟32bit(位)的连续空间，也就是4Btye(字节)空间。
4、有符号整形型赋值范围0和正负整数，无符号整形赋值范围0和正整数。系统默认情况下定义的整形都是有符号的子类。

## 2、数据范围
已知一个int类型数据是4个字节也就是32位bit。

无符号的int最大的数应该是32个bit位都是1，2^32=4294967296。实际上bit位全是1的数会被记为0，因为用全是0的bit位记为0在计算机层面上不容易理解，计算机系统会认为全是0的bit位是没有存储的空白空间。所以无符号的int类型最大数是2^32-1=4294967295，最小数0。
有符号的init最大数应该是31个bit位都是1，同理无符号int类型最大数是2^31-1=2147483647，最小数就是包括符号位所有bit位都是1，当符号位为1数据位全部为0时，最高位1即表示符号位也表示数据位，所以最小数2^31=-2147483648。因为这里与补码相关，详情看补码部分理解。

## 3、运算法则
整形数据与整形数据的运算结果也是整形数据。

demo：
```cpp
int a = 123;
cout << a / 10; //输出12，因为数学上123除以10是12.3，cpp会忽略小数点后的数据，所以得到的结果是12。
```

## 4、总结
因为不同的整形数据所占的内存空间不同，所表示的数据范围也是不同的。
因为c标准中对于数据所占内存空间字节数没有明确的规范，只有一个模糊的区间的范围。只要求long型数据长度不短于int型short型不长与int型，在有的编译器中int和long都是占用4个字节。所以导致了在不同的编译器中运行的结果不同。
通过sizeof运算符可知所在编译器的各种类型数据的所占字节数。

```cpp
cout << sizeif(int); //输出4，该编译器int型数据占4字节空间。
```

了解每个整形子类型在存储空间内具体的存储方式，就知道什么场景下下应该用什么子类型了也有助于理解程序的本质和运行原理。补充请看[二进制的源码补码反码](./程序设计-二进制的原码补码反码.md)。
