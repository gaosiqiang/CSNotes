# 指针

## 1、导读
本文旨在指针的探究和本质原理；

指针学习目标：指针在c语言中占有很重要的地位。从概念上就打好指针方面的基础。关于指针的学习概念是很重要的部分，所以要理解性的学习指针方面的知识。

## 2、指针

### 2.1、指针概念定义
指向一个内存资源的**内存地址**即为**指向该资源的指针**，该内存地址即为**指针**。

通常把某个变量的内存地址称为指向该变量的指针。一个变量的地址就是指向这个变量的指针。

```cpp
int *pointer; //定义了一个指针变量；是指向int类型的指针类型；
int a = 100; //定义了一个int类型变量；
pointer = &a; //&a是指针，pointer是指针变量；
```

### 2.2、指针的意义
通过指针访问指针指向的标定资源。

### 2.3、指针的适用范围
地址运算符&适用的对象不包括表达式、常量、register类型的变量；

### 2.3、指针与指针变量的区别和联系
1、经常将指针变量就直接称作指针；但是指针与之指针变量在概念上是有所区别的；

2、这里表述的是**指针**，而不是**指针变量**，这两个是不同概念。指针变量是存放内存地址的变量，而且指针变量有自己的数据类型也就是指针类型；

3、也就是说指针本质上是值，是变量在内存中的地址；指针变量是存放指针这个值的变量；

### 2.4、指针与内存地址的区别和联系
内存地址只是单纯的内存存储单元对应的地址，是没有类型的，而指针是有类型的；

### 2.5、指针的使用

#### 2.5.1、获取指针
获取方式：通过地址运算符&来获取指针；

获取指针表达式：

```cpp
&加上资源名称; //即可获取该名称资源的指针。也就是资源内存存储区域的起始单元的内存地址。
```

example1

```cpp
int a = 1;
&a; //获取变量a内存存储地址，即为获取指向变量a的指针。
int b;
cout << &a; //打印出变量a的指针。
```

example2

```cpp
#include <iostream>
#include <typeinfo> //引入typeinfo类库
using namespace std;

int main()
{
    int a = 100;
    cout << &a << endl; //输出变量a的指针
    cout << typeid(a).name() << endl; //输出i表示是int类型
    cout << typeid(&a).name() << endl; //输出Pi表示类型是指针，指向整数int资源的指针

    char b;
    b = 'a';
    cout << &b << endl; //输出变量b的指针
    cout << typeid(b).name() << endl; //输出c表示是char类型
    cout << typeid(&b).name() << endl; // 输出Pc表示类型是指针，指向字符char资源的指针

    cout << sizeof(&a) << endl; //输出该指针在内存中的存储多个个字节空间
    cout << sizeof(&b) << endl; //输出该指针在内存中的存储多个个字节空间

    return 0;
}
```


指针的大小可以用sizeof函数获取，同样的代码在不同的编译器中指针的大小是不同的。比如docker的centos是8个字节。

#### 2.5.2、通过指针获取资源
指针运算符&加上资源名只是获取资源的指针，比如`&a;`只是获取a的指针。而获取指针对应的资源就需用另一个：指针运算符*

表达式格式：

```cpp
*加上指针;
```

example：

```cpp
#include <iostream>
using namespace std;

int main()
{
    int a = 100;
    cout << a << endl; //打印a的值，输出100
    cout << &a << endl; //打印a的指针，输出0x7fff8c685fa8，不同的环境可能不同
    int b;
    b = *&a; //将a指针指向的资源赋给b
    cout << b << endl; //打印b的值，输出100
    cout << *&a << endl; //打印a指针指向的资源，输出100
    return 0;
}
```


### 2.6、指针的大小
指针的大小也就是指针变量的大小在不同的编译器是不同的，书上说是4个字节而我cout打印出来的8个字节；

### 2.7、小结

1、`*&c`和`c`在c/cpp代码中是等价的。就是使用指针运算符\*加上指针访问资源和直接在代码中使用资源名访问资源这两种方式是等价的；

2、用指针运算符\*就可以去访问这个指针指向的资源。对于这个变量c的指针，我们又可以用\*加上这个地址，去访问这个资源。如果想用这个地址访问a的值并且打印 `cout << *&a；`；

3、编译时，编译器建立**变量名**到**地址**的映射；

## 3、指针变量

### 3.1、概念定义
1、指针变量：专门用于存储指针（某个资源的内存地址）的变量叫做**指针变量**；但是很多时候就只叫做**指针**；


### 3.2、特点
1、指针变量属于指针数据类型，就是存储指针类型的变量数据类型；，也是变量也遵循变量三要素：名称、资源、指针地址。也就是指针变量自己也有一个属于自己存储空间的指针与普通变量没有什么区别；

2、因为指针变量存储的资源是指针，表述的时候可以称为为：**指向‘资源名’的指针变量**。

3、如果一个变量a的地址也就是指针是另一个指针变量p存储的值，那么这个**p就是指向变量a的指针变量**；

### 3.3、指针变量与其他变量的区别
指针变量只能存储指针类型数据，而普通类型是可以存储除指针类型其他的类型数据；

### 3.4、声明定义指针变量
#### 3.4.1、指针类型的变量声明定义规范
通过指针运算符\*标示了变量为指针变量类型变量，这样就定义了指针类型的变量来存储‘指针’资源；

```cpp
基类型 *变量名;
baseTypeName *pointerVariableName;//定义指针变量
```

> 基类型，用来指定指针变量的基类型。基类型是指针变量所指向变量的数据类型；

> 基类型可以理解为指针变量存储的指针，所指向的资源数据类型，都是c/cpp中基础的常用的类型；

> 这个基类型，称作指针变量的基类型；

#### 3.4.2、声明定义demo：

```cpp
#include <iostream>
using namespace std;

int main()
{
    int *pointer;//定义了一个指针变量。
    return 0;
}
```

指针变量声明定义规范demo代码解析：

- int是基类型，可以把int称作指针变量pointer的基类型。
- *是标识了变量为指针类型
- pointer是指针变量名称


### 3.5、指针变量的使用
#### 3.5.1、指针变量赋值规范
将获取到的变量的指针赋值给指针变量即可。

```cpp
baseTypeName *pointerVariableName;//定义指针变量
pointerVariableName = &variableName;//指针变量的赋值
```

赋值完成后，称为指针变量pointerVariableName指向了变量variableName，也称为pointerVariableName指向variableName；

因为pointerVariableName是指针类型变量，所以直接使用`pointerVariableName = variableName;`变量赋的值不是指针类型数据那么赋值运算是非法代码，指针变量只能接受指针类型数据同时符合基类型的指针才能赋值；

example：

```cpp
#include <iostream>
using namespace std;

int main()
{
    int *pointer; //定义了一个指针变量。
    int a = 100;
    pointer = &a; //&a获取a的指针，然后赋给指针变量pointer。赋值后，称指针变量pointer指向了变量a。
	cout << pointer << endl; //输出的是指针地址
    return 0;
}
```

#### 3.5.2、指针变量访问所指向的变量的规范
指针变量访问存储的指针对应的资源：因为指针变量存储的就只是指针而已，打印出来就可以看到就只是指针而已。可以用指针运算符\*实现访问指针对应的资源；简而言之：通过指针访问资源；

```c++
baseTypeName variableName;//定义基础变量
baseTypeName *pointerVariableName;//定义指针变量
pointerVariableName = &variableName;//指针变量的赋值
cout << *pointerVariableName << endl;//通过*加上指针变量名。可以访问指针变量pointerVariableName存储的指针所指向的variableName变量的资源。
```

\*pointerVariableName就是访问pointerVariableName指针变量内存储的指针所指向的存储单元的内容。这个内容是variableName变量而不是指针变量pointerVariableName存储的指针对应的内存资源；所以\*pointerVariableName可以当做variableName来使用；

#### 3.5.3、空指针

int \*p = NULL;就是将指针变量在初始化赋值为空类型，也就是赋值空指针；

```cpp
int a = 0, b = 0, temp;
int *p1 = NULL, *p2 = NULL;

//这里定义2个int类型基类的指针变量；在初始化的时候分别赋值NULL，这里是定义了2个空指针变量，表示这2个指针变量的值是空的；

//定义指针变量的时候为什么要初始化值，因为如果不初始化值那么指针变量的值是不确定的，万一是个地址那就会很危险；

//原则上所有变量在声明定义的时候就应该初始化；初始化就是赋初始化的值
```

## 4、运算符的优先级
&和\*运算符的优先级：

优先级表（从高到低）：
- 1、后置++、后置--；
- 2、前置++、前置--、逻辑非（ ！）、\*、&
- 3、算数运算符
- 4、关系运算符
- 5、&&、||
- 6、赋值运算符

如果同级的多个运算符在同一个表达：
1、运顺序：是从右到左和从被运算的标示符最近的运算符开始运算；
2、结合顺序：是从右向左；

demo：
```cpp
&*pointer;//先运算*pointer然后在运算*pointer的结果；
*&a;//先运算*a然后在运算*a的结果；
*a++;//先运算a++然后在运算a++的结果；
```

## 5、指针++--

```cpp
int a = 0;
int *p = NULL;
p = &a;
cout << p << endl; //0x7fff92b4cb24
p++;
cout << p << endl;//0x7fff92b4cb28
```

理论上p应该输出（都是16进制的数据）0x7fff92b4cb24+1也就是0x7fff92b4cb25的结果是0x7fff92b4cb24+4 = 0x7fff92b4cb28；

代码说明：
1、因为在代码系统内变量a是int类型数据，在内存存储的区域是0x7fff92b4cb24到0x7fff92b4cb27这4个存储单元（字节）都是给变量a划分的，是不可分割的；

2、所以当系统执行到p++的自加1的时候就直接跨国当前被占用的字节数量，直接开辟在后面。这就是声明定义指针变量要规范基类的作用之一；

## 6、指针与数组

### 6.1、指针与数组元素

```cpp
int a[5] = {1, 2, 3, 4, 5};
cout << a[3] << endl; //4
int *p = NULL;
p = &a[3];
cout << *p << endl;//4
*p = 10;
cout << a[3] << endl;//10
```

结论：指针变量指向数组元素与指向变量没有区别；

### 6.2、指针与数组名

```cpp
int a[5] = {1, 2, 3, 4, 5};
cout << a << endl; // 0x7fff7c2a1b10
cout << *a << endl; // 1
cout << &a[0] << endl; // 0x7fff7c2a1b10
cout << a[0] << endl; // 1
```

代码说明：

结论：


## 引用参考

## 拓展-1

### 详情
连接：https://apod.nasa.gov/apod/image/0403/n49_hst_full.jpg
名称：N49星云
图片：![](./images/n49_hst_full.jpeg)


### 说明

1、通过连接就可以获取到名字叫N49星云的图片资源。连接就是这是图片的地址。图片就是连接对应的对应的资源，名称就是该资源的名称；

2、可以把连接称为指向这个资源的指针（这里资源这里是指图片）

3、这个连接就把它称作指针；

4、存储这个链接的变量就是指针变量；

## Q&A
- 指针是不是就是内存地址？指针变量是否只是存储指针的变量？